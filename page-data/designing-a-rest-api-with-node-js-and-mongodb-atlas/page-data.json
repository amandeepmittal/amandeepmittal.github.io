{"componentChunkName":"component---src-templates-post-js","path":"/designing-a-rest-api-with-node-js-and-mongodb-atlas","webpackCompilationHash":"c3a562291cd8e443a353","result":{"data":{"site":{"siteMetadata":{"title":"Aman Mittal - Fullstack Developer","description":"Aman Mittal - Developer and Technical writer.","author":{"name":"Aman Mittal"},"keywords":["Fullstack Developer"]}},"mdx":{"frontmatter":{"title":"Designing a REST API with Node.js and MongoDB Atlas","date":"January 22, 2018","author":"Aman Mittal","banner":null,"slug":"designing-a-rest-api-with-node-js-and-mongodb-atlas","keywords":null},"code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"slug\": \"designing-a-rest-api-with-node-js-and-mongodb-atlas\",\n  \"date\": \"2018-01-22T00:00:00.000Z\",\n  \"title\": \"Designing a REST API with Node.js and MongoDB Atlas\",\n  \"categories\": [\"nodejs\"],\n  \"description\": \"---\",\n  \"published\": true,\n  \"author\": \"Aman Mittal\",\n  \"banner\": null\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/800/1*AGkeiH2qqfF1GI_0o3WNww.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Nodejs is a remarkable technology for the fulfilling and developing web applications. Being open source and in the past few years, we have seen it rising. It might be a bit different from other traditional web technologies in terms of learning curve but I urge you to stick with it if you are getting in to web development and have opted \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.zeolearn.com/node-js-training\"\n  }), \"Node.js\"), \" ecosystem. In this tutorial, I will walk you through the basics of REST API design with using Node.js ecosystem.\"), mdx(\"p\", null, \"I\\u2019d love if you follow along with me with snippets of code that are in continuation below. Before we begin, I want you to understand what is REST and how its beneficial to use it with server side JavaScript.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"What is REST?\")), mdx(\"p\", null, \"REST is an acronym for Representation State Transfer and is an industry standard (till Graphql conquers the world) for defining how an API and its endpoint (routes) should communicate with the server code of your web application. A REST API consumes HTTP methods such GET, POST, etc. with endpoints that are nothing but URLs that you can use to fetch some data or update/create new data in the database. In his \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.ics.uci.edu/%7Efielding/pubs/dissertation/rest_arch_style.htm\"\n  }), \"whitepaper\"), \", Roy Fielding described the paradigms and practical use of REST. I am going to summarise points what he exactly says in that paper. The basis of a RESTful API depends on below:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Client-Server\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Stateless\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Uniform Interface\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Cacheable\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Layered System\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Code-On-Demand style\")), mdx(\"p\", null, \"To read about them in detail, please see Roy Fielding\\u2019s paper on the same \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.ics.uci.edu/%7Efielding/pubs/dissertation/rest_arch_style.htm\"\n  }), \"here\"), \".\"), mdx(\"p\", null, \"Applications that make use of REST APIs perform four basic operations that are known as CRUD.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"C: Creating data\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"R: Reading data\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"U: Updating data\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"D: Deleting/removing data\\u200B\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Prequisites\")), mdx(\"p\", null, \"There are some things we need to go through this tutorial successfully.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://nodejs.org/\"\n  }), \"Node.js\"), \" installed\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Access to \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.mongodb.com/\"\n  }), \"MongoDB\"), \", a NoSQL database on your local machine or cloud\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"IDE/Editor\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.getpostman.com/\"\n  }), \"Postman\"), \", a REST client to test our API\\u2019s endpoints\")), mdx(\"p\", null, \"If you do not have \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.zeolearn.com/mongodb-training\"\n  }), \"MongoDB\"), \" installed on your local mahcine, do not worry. In the next step I am going walk you through setting up a free tier of MongoDB in cloud.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Consuming MongoDB in Cloud\")), mdx(\"p\", null, \"For the sake of brevity, I am going to use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.mongodb.com/cloud/atlas\"\n  }), \"MongoDB Atlas\"), \" a service that you can use to store data for your sample application. You can also use other popular database-as-a-service \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://mlab.com/\"\n  }), \"Mlab\"), \" without any hassle.\"), mdx(\"p\", null, \"I already have an account setup, so I\\u2019d suggest you to sign up on mongodb atlas\\u2019 site with your email. Once you have logged in, you will get the below screen:\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/1200/0*K-3GHE1axS48h85u.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"At this point, you can either take time to explore what MongoDB Atlas is or you can skip and together we will setup a Sandbox for our sample application. Click on the \\u201CNew Project\\u201D button on the right side of the web page.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://d6vdma9166ldh.cloudfront.net/media/images/b7a62c69-71a3-4678-89d3-276832706d9a.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://d6vdma9166ldh.cloudfront.net/media/images/e910bddb-5e50-4d0a-aaa4-d7d36939e491.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Then you will be prompted to fill in the details. See screenshots below, enter a name for your project and click \\u201Cnext\\u201D and then click \\u201CCreate Project\\u201D. Per one account in MongoDB Atlas, you will get one free tier/cluster. Follow the steps below to setup one.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://d6vdma9166ldh.cloudfront.net/media/images/71db2429-c41d-48bb-a9e1-21281f5cfbcb.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Click on the Build new Cluster button.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://d6vdma9166ldh.cloudfront.net/media/images/145b86aa-63c1-45e4-ae53-f92bdf852562.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Scroll down a bit, and then select the free tier M0. Per free cluster, we get 512mb of space. More than enough for what we need for this tutorial.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://d6vdma9166ldh.cloudfront.net/media/images/9c0385c7-e282-4fd7-a266-487425841b0e.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Then enter username and password for an Admin connection that we will use to connect to our database through our application. Make sure you remember both username and password and password must a bit strong. Lastly, click on confirm and deploy and the service will take at least 10 minutes to setup a database cluster.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://d6vdma9166ldh.cloudfront.net/media/images/17807485-9b69-43c4-9d83-e9c7aa5abb1f.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"That\\u2019s it. The database is now ready to be used. Now let us setup our application.\"), mdx(\"h2\", null, \"Configuring Server Side\"), mdx(\"p\", null, \"From your terminal:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"# to initalise our node project, we need a package.json file\\nnpm init --yes\\n\\n# install express framework\\nnpm install -S express mongoose body-parser\\n\")), mdx(\"p\", null, \"Mongoose is client that helps us connect and communicate with our database. BodyParser is needed as a middleware to parse the data to be sent through HTTP requests. Express is de facto standard and is one of the reason we will be using it.\"), mdx(\"h2\", null, \"Running the Server\"), mdx(\"p\", null, \"Let\\u2019s first the nitty gritties of our server. Create a file app.js in the root directory with the following code:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// app.js\\n\\nconst express = require('express')\\n\\nconst app = express()\\n\\nconst port = process.env.PORT || 3301\\n\\napp.listen(port, () => {\\n  console.log(`Server running at http://localhost:${port}`)\\n})\\n\")), mdx(\"p\", null, \"The app is an object provided by Express API for the developer to communicate with the application and bootstrap a server. In Express application, it is that easy to write bare minimum server. There are different ways you can setup your server but the basics will remain same. For brevity, I am using app.js but you can take a look at Express generator that scaffolds a structure in a quick manner.\"), mdx(\"p\", null, \"Now, add an npm script to package.json file to test and start our server.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"\\\"scripts\\\": {\\n    \\\"start\\\": \\\"node app.js\\\",\\n    \\\"test\\\": \\\"echo \\\\\\\"Error: no test specified\\\\\\\" && exit 1\\\"\\n  },\\n\")), mdx(\"p\", null, \"From terminal, npm run start or npm start and you should see the success message without any error.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://d6vdma9166ldh.cloudfront.net/media/images/180b1cc9-7178-44ff-8319-8747548ad6cd.png\",\n    \"alt\": null\n  }))), mdx(\"h2\", null, \"Setting up Mongoose\"), mdx(\"p\", null, \"Mongoose is an ORM (Object Relational Mapper) that is used to interact with MongoDB database instance. We have already setup our instance using MongoDB atlas and installed mongoose as the project dependency. So let us start by defining a schema. Though, NoSQL database are schema less it is consider a best practice to define a schema to give some structure to the data that will be stored in our database.\"), mdx(\"p\", null, \"A typical Express application follows MVC (model-view-controller) model to define a directory structure and that is what we are going to do. Create a directory models and inside it a file Task.js with following code:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const mongoose = require('mongoose')\\nconst Schema = mongoose.Schema\\n\\nconst TaskSchema = new Schema({\\n  taskName: {\\n    type: String,\\n    required: true\\n  },\\n  createdOn: {\\n    type: Date,\\n    default: Date.now\\n  }\\n})\\n\\nmodule.exports = mongoose.model('Tasks', TaskSchema)\\n\")), mdx(\"p\", null, \"This schema does look like a JSON data and that is exactly what MongoDB stores or it appears to be for the developer to. Original format of data stored in MongoDB is called BSON (stands for \", \"_\", \"Binary JSON) and it converts JSON to BSON is handled by the dtabase itself. You can read more about it here in the official docs.\"), mdx(\"p\", null, \"Mongoose allows us to create define a schema for our the document to be stored in our application via inside the application just by defining a model. You can think it of as a blueprint. All your tasks in the database collection, will have taskName and createdOn value. Lastly, we bind our schema with the name of our collection Tasks. The collection in MongoDB our by default plural since they tend to contain a number of documents. taskName and createOn are called fields in terms of MongodB terminology. Together they constitute a document inside the collection Tasks and each document will have a unique ID to identify them as a record in the database. This unique ID is stored in MongoDB database by default and is a 12 byte value made up of different things related to our database. You can read more about how this unique ID created by the database \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.mongodb.com/manual/reference/method/ObjectId/\"\n  }), \"here\"), \".\"), mdx(\"h2\", null, \"Connecting Database To our Application\"), mdx(\"p\", null, \"Before we further go with the controller part, let us first connect the database to our server and see if everything is working A-OK.\"), mdx(\"p\", null, \"I like to store all my application\\u2019s configuration in a config directory. Create a db.js file inside that directory.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const mongoose = require('mongoose')\\n\\nconst dbURI =\\n  'mongodb://newuser:myNewPassword@cluster0-shard-00-00-gibou.mongodb.net:27017,cluster0-shard-00-01-gibou.mongodb.net:27017,cluster0-shard-00-02-gibou.mongodb.net:27017/test?ssl=true&replicaSet=Cluster0-shard-0&authSource=admin'\\n\\nconst options = {\\n  reconnectTries: Number.MAX_VALUE,\\n  poolSize: 10\\n}\\n\\nmongoose.connect(dbURI, options).then(\\n  () => {\\n    console.log('Database connection established!')\\n  },\\n  err => {\\n    console.log('Error connecting Database instance due to: ', err)\\n  }\\n)\\n\\n// require any models\\n\\nrequire('../models/Task')\\n\")), mdx(\"p\", null, \"To get the connection string you have to follow the following steps:\"), mdx(\"p\", null, \"First click on the connect button on your MongoDB Atlas page the following screen will prompt.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://d6vdma9166ldh.cloudfront.net/media/images/1ed9e590-2aad-47e2-989b-95bcad69e339.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Then, click \\u201CAllow Access from Anywhere\\u201D to white list our server URL.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://d6vdma9166ldh.cloudfront.net/media/images/1434b0f6-7bde-4e3c-8a13-68fe382894e2.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Then, copy the URI string for version 3.4:\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://d6vdma9166ldh.cloudfront.net/media/images/d7458a10-1220-4c67-ac1f-eafcce4190b4.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"And enter the username and password you entered during the setup of our instance in place of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"username:<password>\"), \" and remove the placeholders \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<>\"), \". I am using options variable to spike your curiosity such that you will explore about it and the power of mongoose. You can read more about connection options that provided by mongoose here.\"), mdx(\"p\", null, \"Lastly, we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mongoose.connect()\"), \" to establish a connection between server and the database instance and handle it gracefully using a promise. But wait, the connection won't be establish until we connect this config file with our application and for that we need to require this file in our main app.js file.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const express = require('express')\\n\\n// db instance connection\\nrequire('./config/db')\\n\\nconst app = express()\\n\\nconst port = process.env.PORT || 3301\\n\\napp.listen(port, () => {\\n  console.log(`Server running at http://localhost:${port}`)\\n})\\n\")), mdx(\"p\", null, \"Now restart our server from command line and you will see the success prompt:\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://d6vdma9166ldh.cloudfront.net/media/images/2f7929df-6a92-4823-b48d-a7e3cffe86ee.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Do you notice one thing here? For every change we make in our application, we have to restart our server from command line and to ignore this tedious process we can make use of a powerful utility called nodemon developed by Remy Sharp.\"), mdx(\"h2\", null, \"Enter Nodemon\"), mdx(\"p\", null, \"After we setup nodemon I promise we will be focusing on code of our API but making use of this utility will save tons of amount of time when working on an API yourself. Let's install nodemon as a dev dependency first.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"npm install -D nodemon\\n\")), mdx(\"p\", null, \"After installing it, change the start script in package.json file to:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"npm install -D nodemon\\n\")), mdx(\"p\", null, \"Now if we start our server, nodemon will monitor for any changes made and restart the server when necessary on its own. We don\\u2019t have to worry about that anymore.\"), mdx(\"p\", null, \"Back to our API code.\"), mdx(\"h2\", null, \"Setting up Business Logic\"), mdx(\"p\", null, \"To setup routes or endpoints of our application, we need to include \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"body-parser\"), \" in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app.js\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const express = require('express')\\nconst bodyParser = require('body-parser')\\n\\n// db instance connection\\nrequire('./config/db')\\n\\nconst app = express()\\n\\nconst port = process.env.PORT || 3301\\napp.use(bodyParser.urlencoded({ extended: true }))\\napp.use(bodyParser.json())\\n\\napp.listen(port, () => {\\n  console.log(`Server running at http://localhost:${port}`)\\n})\\n\")), mdx(\"p\", null, \"BodyParser parses incoming HTTP requests as middleware under req.bodybefore routes or API have access to them and perform any further actions on them. Very useful and essential step when using forms in a web application.\"), mdx(\"p\", null, \"To define the business logic of our APIs endpoints, we are going to create a separate file TaskController.js under directory controllers.\"), mdx(\"p\", null, \"For our API routes (I am going to call them route for brevity but they are same as endpoints) we are going to five different actions or operations or way to handle incoming requests. These tasks will cover our CRUD operations. Each route will have at least two parameters: req and res.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"req\"), \": request, useful when creating or or updating a new task and read data from the body (this where BodyParser works like a charm).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"res\"), \": response to fulfill that incoming request with response.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const Task = require('../models/Task')\\n\\nexports.listAllTasks = (req, res) => {\\n  Task.find({}, (err, task) => {\\n    if (err) {\\n      res.status(500).send(err)\\n    }\\n    res.status(200).json(task)\\n  })\\n}\\n\\nexports.createNewTask = (req, res) => {\\n  let newTask = new Task(req.body)\\n  newTask.save((err, task) => {\\n    if (err) {\\n      res.status(500).send(err)\\n    }\\n    res.status(201).json(task)\\n  })\\n}\\n\\nexports.readTask = (req, body) => {\\n  Task.findById(req.params.taskid, (err, task) => {\\n    if (err) {\\n      res.status(500).send(err)\\n    }\\n    res.status(200).json(task)\\n  })\\n}\\n\\nexports.updateTask = (req, res) => {\\n  Task.findOneAndUpdate(\\n    { _id: req.params.taskid },\\n    req.body,\\n    { new: true },\\n    (err, task) => {\\n      if (err) {\\n        res.status(500).send(err)\\n      }\\n      res.status(200).json(task)\\n    }\\n  )\\n}\\n\\nexports.deleteTask = (req, res) => {\\n  Task.remove({ _id: req.params.taskid }, (err, task) => {\\n    if (err) {\\n      res.status(404).send(err)\\n    }\\n    res.status(200).json({ message: 'Task successfully deleted' })\\n  })\\n}\\n\")), mdx(\"p\", null, \"This completes our controller. The controller is the business logic that binds our endpoints/routes that we are going to define soon to what action or operation they will perform on an incoming request.\"), mdx(\"p\", null, \"Each of the above operation when sending a response does send HTTP status code which clearly determines whether the incoming request was fulfilled or was there an error. This the part of REST paradigm and is best practice. You can read more about this \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.restapitutorial.com/lessons/httpmethods.html\"\n  }), \"here\"), \".\"), mdx(\"h2\", null, \"Setting up Routes\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const express = require('express')\\nconst bodyParser = require('body-parser')\\nconst taskController = require('./controllers/TaskController')\\n\\n// db instance connection\\nrequire('./config/db')\\n\\nconst app = express()\\n\\nconst port = process.env.PORT || 3301\\napp.use(bodyParser.urlencoded({ extended: true }))\\napp.use(bodyParser.json())\\n\\n// API ENDPOINTS\\n\\napp\\n  .route('/tasks')\\n  .get(taskController.listAllTasks)\\n  .post(taskController.createNewTask)\\n\\napp\\n  .route('/tasks/:taskid')\\n  .get(taskController.readTask)\\n  .put(taskController.updateTask)\\n  .delete(taskController.deleteTask)\\n\\napp.listen(port, () => {\\n  console.log(`Server running at http://localhost:${port}`)\\n})\\n\")), mdx(\"p\", null, \"We setup our API\\u2019s endpoints by first requiring the controller and then passing on a specific endpoint it using the correct HTTP method. The endpoints can be elaborated as:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"POST /tasks to create a new task\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"GET /tasks to get a list of all tasks\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"GET /tasks/:taskid to get a specific task by its unique id(the one mongodb creates for us)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"PUT /tasks/:taskid to modify existing task\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"DELETE /tasks/:taskid to delete an existing task from our database instance\"))), mdx(\"p\", null, \"As a best practice, APIs routes should always use nouns for identifying resource.\"), mdx(\"p\", null, \"Now let us test our API routes using Postman.\"), mdx(\"h2\", null, \"Testing our API\"), mdx(\"p\", null, \"Open postman and type \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://localhost:3301/tasks\"\n  }), \"http://localhost:3301/tasks\"), \" and selct the POSTmethod. We will first use the POST request to create a new task since our database is currently empty and does not have any data. Use body to fill in the data which follows same schema we defined in our model.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://d6vdma9166ldh.cloudfront.net/media/images/36858c3c-1a16-4a84-9821-804b2b5435dc.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Hitting the send button should respond with 200 status and the data we created structured exactly like our schema in JSON format.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://d6vdma9166ldh.cloudfront.net/media/images/eb03c175-41f7-4bc0-859a-0a007086af91.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Similarly, we can test other endpoints of our API. Such as getting all tasks (so far we have so it will give only one task that we just created):\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://d6vdma9166ldh.cloudfront.net/media/images/b1300d7d-6493-43b0-8e10-e4642e57e421.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Getting the task by its \", \"_\", \"id:\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://d6vdma9166ldh.cloudfront.net/media/images/86018023-045d-4cc5-8db4-cead1261a6a4.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Try updating the task or removing it by using the endpoints we defined earlier and changing the HTTP method from Postman yourself.\"), mdx(\"p\", null, \"Hope you learned something valuable by reading this article.\"), mdx(\"p\", null, \"You can find the complete code at this \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/amandeepmittal/nodejs-restapi\"\n  }), \"Github repository\"), \".\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.zeolearn.com/magazine/designing-a-rest-api-with-nodejs-and-mongodb-atlas\"\n  }), \"Originally Published at Zeolearn.com\"))));\n}\n;\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"e4adece1-850c-5344-a9b2-b2bbb29d1e35","prev":{"id":"04ef9f5f-982a-52a5-b284-d7497fcbaa36","parent":{"name":"index","sourceInstanceName":"blog"},"excerpt":"Progressive Web App with React!  When I read this I thought, why not build one ourselves. If you are familiar with React and a bit about its ecosystem such as Create-React-App utility, this guide is for you. If you spend at least third quarter of…","fields":{"title":"Build a Progressive Web App using React","slug":"build-a-progressive-web-app-using-react","date":"2018-02-01T00:00:00.000Z"},"code":{"scope":""}},"next":{"id":"174554f7-dab9-50f9-b964-c712cd745724","parent":{"name":"index","sourceInstanceName":"blog"},"excerpt":"Gatsby  is a static site generator for React that released its first major version last month. It’s a tool that not only scaffolds projects (or websites) for you but claims that those sites are fast in performance. If you decide to use Gatsby you…","fields":{"title":"Gatsby.js: How to set up and use the React Static Site Generator","slug":"setting-up-and-getting-used-to-gatsby","date":"2018-01-04T00:00:00.000Z"},"code":{"scope":""}}}}}