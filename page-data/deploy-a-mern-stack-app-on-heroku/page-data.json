{"componentChunkName":"component---src-templates-post-js","path":"/deploy-a-mern-stack-app-on-heroku","webpackCompilationHash":"c3a562291cd8e443a353","result":{"data":{"site":{"siteMetadata":{"title":"Aman Mittal - Fullstack Developer","description":"Aman Mittal - Developer and Technical writer.","author":{"name":"Aman Mittal"},"keywords":["Fullstack Developer"]}},"mdx":{"frontmatter":{"title":"Deploy a MERN stack app on Heroku","date":"October 12, 2018","author":"Aman Mittal","banner":null,"slug":"deploy-a-mern-stack-app-on-heroku","keywords":null},"code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"slug\": \"deploy-a-mern-stack-app-on-heroku\",\n  \"date\": \"2018-10-12T00:00:00.000Z\",\n  \"title\": \"Deploy a MERN stack app on Heroku\",\n  \"categories\": [\"MERN stack\"],\n  \"description\": \"How to deploy an existing web app built using MongoDB, ExpressJS, Node.js, and Reactjs (often called as MERN stack) on Heroku\",\n  \"published\": true,\n  \"author\": \"Aman Mittal\",\n  \"banner\": null\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/1200/1*1Gz17g154lpi9rOY8TPM2Q.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"In this article, I will describe how to take an existing Web Application that is build using MongoDB, ExpressJS, \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://crowdbotics.com/build/node-js?utm_source=medium&utm_campaign=nodeh&utm_medium=node&utm_content=mern\"\n  }), \"Node.js\"), \", and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.crowdbotics.com/build/react\"\n  }), \"React\"), \" (often called as MERN stack) on a deployment service like Heroku. If you have an existing application built using the same tech stack, you can definitely skip the process in which I show you to quickly build a web application and go straight on to the deployment part. For the rest of you, please continue to read.\"), mdx(\"h3\", null, \"MERN Stack\"), mdx(\"p\", null, \"MongoDB, ExpressJS, Node.js, and Reactjs are used together to build web applications. In this, Node.js and Express bind together to serve the backend, MongoDB provides a NoSQL database to store the data and frontend is built using React that a user interacts with. All four of these technologies are open source, cross-platform and JavaScript based. Since they are JavaScript based, one of the main reasons why they are often used together.\"), mdx(\"p\", null, \"As JavaScript is used throughout to build a Fullstack application, developers do not need to learn and change the context of using different programming languages to build or work on different aspect of a web application.\"), mdx(\"p\", null, \"To continue to follow this tutorial there are requirements that you will need to build the demo application and then deploy it on Heroku.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Node.js/npm installed\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Heroku account\")), mdx(\"p\", null, \"For MongoDB, we are going to use a cloud based service like mLab which provides database as a service. It has a free tier, and having an account there will be time saving.\"), mdx(\"h2\", null, \"Building a Full-stack app using\\xA0MERN\"), mdx(\"h3\", null, \"Building the\\xA0Backend\"), mdx(\"p\", null, \"I am going to take you through building a web application using MERN Stack. To start, please create an empty directory and type the following commands in the order they are specified.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"# to generate package.json\\nnpm init -y\\n\\n# install following dependencies\\nnpm install -S express mongoose\\n\\nnpm install -D nodemon\\n\")), mdx(\"p\", null, \"Create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"server.js\"), \" file inside the root of the directory. This file will server us the backend file for us.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// server.js\\nconst express = require('express');\\nconst app = express();\\n\\nconst PORT = process.env.PORT || 5000;\\n\\n// configure body parser for AJAX requests\\napp.use(express.urlencoded({ extended: true }));\\napp.use(express.json());\\n\\n// routes\\napp.get('/', (req, res) => {\\n    res.send('Hello from MERN');\\n});\\n\\n// Bootstrap server\\napp.listen(PORT, () => {\\n    console.log(`Server listening on port ${PORT}.`);\\n});\\n\")), mdx(\"p\", null, \"Now, I made following changes in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"package.json\"), \" for this program to work.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"\\\"main\\\": \\\"server.js\\\",\\n    \\\"scripts\\\": {\\n    \\\"server\\\": \\\"nodemon server.js\\\",\\n  }\\n\")), mdx(\"p\", null, \"To see if everything is working, run the command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm start server\"), \" that we just defined in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"package.json\"), \" as a script. If there are no errors, you will get the following result. Visit the following url: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[http://localhost:5000](http://localhost:5000.)\"), mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://localhost:5000.\"\n  }), \".\")), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/800/1*fza80DTPXuhFwJapj2ZIbQ.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Please note that onwards Express version \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"4.16.0\"), \" body parser middleware function is a built-in middleware and there is no need to import it as a separate dependency. Body parser middleware is required to handle incoming AJAX requests that come in the form of JSON payloads or urlencoded payloads.\"), mdx(\"h3\", null, \"Models with\\xA0Mongoose\"), mdx(\"p\", null, \"When I am not writing JavaScript, I am a bibliophile. Thus, for this demonstration, I am going to build a web application that tends to take care of all the books that I want to read. If you are into books, you can think of it is as your own personal TBR manager.\"), mdx(\"p\", null, \"I will start by creating a database model called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Book\"), \" inside the file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"models/Books.js\"), \". This will resemble a schema of what to expect from the user when adding information to our application.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Books.js\\nconst mongoose = require('mongoose');\\nconst Schema = mongoose.Schema;\\n\\nconst bookSchema = new Schema({\\n    title: {\\n        type: String,\\n        required: true\\n    },\\n    author: {\\n        type: String,\\n        required: true\\n    }\\n});\\n\\nconst Book = mongoose.model('Book', bookSchema);\\n\\nmodule.exports = Book;\\n\")), mdx(\"p\", null, \"I am using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mongoose\"), \" to define the schema above. Mongoose is an ODM (Object Document Mapper). It allows you to define objects with a strongly typed schema that is mapped as a MongoDB collection. This schema architecture allows us to provide an organized shape to the document inside the MongoDB collection.\"), mdx(\"p\", null, \"In our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bookSchema\"), \" we are defining two fields: a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"title\"), \" which indicates the title of the book and an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"author\"), \" representing the name of the author of the book. Both these fields are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \" type.\"), mdx(\"h3\", null, \"Defining Routes\"), mdx(\"p\", null, \"Our application is going to need some routes that will help the client app to communicate with the server application and perform CRUD (Create, Read, Update, Delete) operations. I am defining all the business logic that works behind every route in a different file. Conventionally, named as controllers. Create a new file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"controllers/booksController.js\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// booksControllers.js\\nconst Book = require('../models/Books');\\n\\n// Defining all methods and business logic for routes\\n\\nmodule.exports = {\\n    findAll: function(req, res) {\\n        Book.find(req.query)\\n            .then(books => res.json(books))\\n            .catch(err => res.status(422).json(err));\\n    },\\n    findById: function(req, res) {\\n        Book.findById(req.params.id)\\n            .then(book => res.json(book))\\n            .catch(err => res.status(422).json(err));\\n    },\\n    create: function(req, res) {\\n        Book.create(req.body)\\n            .then(newBook => res.json(newBook))\\n            .catch(err => res.status(422).json(err));\\n    },\\n    update: function(req, res) {\\n        Book.findOneAndUpdate({ _id: req.params.id }, req.body)\\n            .then(book => res.json(book))\\n            .catch(err => res.status(422).json(err));\\n    },\\n    remove: function(req, res) {\\n        Book.findById({ _id: req.params.id })\\n            .then(book => book.remove())\\n            .then(allbooks => res.json(allbooks))\\n            .catch(err => res.status(422).json(err));\\n    }\\n};\\n\")), mdx(\"p\", null, \"The business logic or you can say the controller logic behind the application is nothing but the methods that will work on a specific route. There are five functions in total. Each has its own use. I am requiring our Book model, previously created, as it provides functions for us to query CRUD operations to the database. A mongoose query can be executed in two ways, by providing a callback function or by using\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".then()\"), \" function which also indicates that mongoose support promises. I am using the promising approach above to avoid the nuisance caused by nested callbacks (and commonly known as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"callback hell\"), \").\"), mdx(\"p\", null, \"Next step is to use these methods in our routes inside \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"routes/\"), \" directory. Create a new file called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"books.js\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// books.js\\n\\nconst router = require('express').Router();\\nconst booksController = require('../controllers/booksController');\\n\\nrouter\\n    .route('/')\\n    .get(booksController.findAll)\\n    .post(booksController.create);\\n\\nrouter\\n    .route('/:id')\\n    .get(booksController.findById)\\n    .put(booksController.update)\\n    .delete(booksController.remove);\\n\\nmodule.exports = router;\\n\")), mdx(\"p\", null, \"I have separated the concerned routes that match a specific URL. For example, routes that are starting with\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":id\"), \" routing parameter are defined above together in the file. Open \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.js\"), \" in the same directory and add the following.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// index.js\\n\\nconst router = require('express').Router();\\nconst bookRoutes = require('./books');\\n\\nrouter.use('/api/books', bookRoutes);\\n\\nmodule.exports = router;\\n\")), mdx(\"p\", null, \"I am adding a prefix \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/api/books\"), \" before the routes. This way, you can only access them as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[http://localhost:5000/api/books](http://localhost:5000/api/books.)\"), mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://localhost:5000/api/books.\"\n  }), \".\")), mdx(\"p\", null, \"For this to work, I am going to import book routes in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"server.js\"), \" file after every other middleware defined and before we have bootstrapped the server.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// server.js\\n\\nconst routes = require('./routes');\\n\\n// after all middleware functions\\n\\napp.use(routes);\\n\")), mdx(\"p\", null, \"Also remove the default route \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app.get('/')...\"), \" that was previously created. We are soon going to serve the application's front end here on the default route.\"), mdx(\"h3\", null, \"Connecting with Database using\\xA0mLab\"), mdx(\"p\", null, \"I am going to use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://mlab.com\"\n  }), mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"mlab\")), \" to host the database of our application on the cloud. Once you create an account, your dashboard will look similar to mine. I already have few sandboxes running, so do not mind them.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/800/1*gnhdXtIORiT1EsMEv3MSUg.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"To create a new one, click on the button \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Create New\"), \" under MongoDB deployments. After that, you select the plan type Sandbox which provides the free tier up to 500MB.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/800/1*LiDzbwLDCpC-e4Igs7qptg.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"After the MongoDB deployment is created, a database user is required by the mlab to have you connect to this database. To create one now, visit the \\u2018Users\\u2019 tab and click the \\u2018Add database user\\u2019 button.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/800/1*GyHzO_0P76__Y6_UOG1zXA.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Now copy the string provided by mlab such as:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mongodb://<dbuser>:<dbpassword>@ds125453.mlab.com:25453/mern-example\")), mdx(\"p\", null, \"and add the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dbuser\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dbpassword\"), \" you just entered to create the new user. I am going to save these credentials as well as the string given by mlab to connect to the database inside a file called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"config/index.js\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// config/index.js\\nconst dbuser = 'xxxxxxxxxx';\\nconst dbpassword = 'xxxxxxxxx';\\n\\nconst MONGODB_URI = `mongodb://${dbuser}:${dbpassword}@ds125453.mlab.com:25453/mern-example`;\\n\\nmodule.exports = MONGODB_URI;\\n\")), mdx(\"p\", null, \"You can replace the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \"'s for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dbuser\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dbpassword\"), \". Now to define the connection with mlab string we are again going to use mongoose. Create a new file inside \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"models/index.js\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// models/index.js\\n\\nconst mongoose = require('mongoose');\\nconst URI = require('../config/index');\\n\\nmongoose.connect(process.env.MONGODB_URI || URI);\\n\\n// When successfully connected\\nmongoose.connection.on('connected', () => {\\n    console.log('Established Mongoose Default Connection');\\n});\\n\\n// When connection throws an error\\nmongoose.connection.on('error', err => {\\n    console.log('Mongoose Default Connection Error : ' + err);\\n});\\n\")), mdx(\"p\", null, \"We are importing the same database URI string that we just exported in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"config\"), \". I am going to require this file inside our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"server.js\"), \" before any middleware is defined.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// server.js\\nconst express = require('express');\\nconst app = express();\\n\\nconst routes = require('./routes');\\n\\nconst PORT = process.env.PORT || 5000;\\n\\n// require db connection\\nrequire('./models');\\n\\n// configure body parser for AJAX requests\\napp.use(express.urlencoded({ extended: true }));\\napp.use(express.json());\\n\\napp.use(routes);\\n\\n// Bootstrap server\\napp.listen(PORT, () => {\\n    console.log(`Server listening on port ${PORT}.`);\\n});\\n\")), mdx(\"p\", null, \"Now run the server again and if you get the following message, that means your database is gracefully connected to the web server.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/800/1*560qCrzs2900Z2zqwUK2oA.png\",\n    \"alt\": null\n  }))), mdx(\"h3\", null, \"Building the FrontEnd with\\xA0React\"), mdx(\"p\", null, \"To build the user interface of our application, I am going to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"create-react-app\"), \". Run the following command to generate a react application inside a directory called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"create-react-app client/\\n\")), mdx(\"p\", null, \"Once the scaffolding process is complete, run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm run start\"), \" after traversing inside the client directory from your terminal, and see if everything works or not. If you get a screen like below that means everything is top-notch.\"), mdx(\"p\", null, \"Install two dependencies from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm\"), \" that we need to in order for the client to work.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"yarn add axios react-router-dom@4.1.2\\n\")), mdx(\"p\", null, \"You are going to need \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"axios\"), \" to make AJAX requests to the server. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"react-router-dom\"), \" is for switching between navigation routes.\"), mdx(\"p\", null, \"I am not going to walk you through every component and reusable component I have built in this application. I am only going to take you through what needs to be done connect the React app to Node.js server, the build process and then deploying it.\"), mdx(\"p\", null, \"The main frontend file, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App.js\"), \" looks like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import React from 'react';\\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\\nimport Books from './pages/Books';\\nimport Detail from './pages/Detail';\\nimport NoMatch from './pages/NoMatch';\\nimport Nav from './components/Nav';\\n\\nconst App = () => (\\n    <Router>\\n        <div>\\n            <Nav />\\n            <Switch>\\n                <Route exact path=\\\"/\\\" component={Books} />\\n                <Route exact path=\\\"/books\\\" component={Books} />\\n                <Route exact path=\\\"/books/:id\\\" component={Detail} />\\n                <Route component={NoMatch} />\\n            </Switch>\\n        </div>\\n    </Router>\\n);\\n\\nexport default App;\\n\")), mdx(\"p\", null, \"Next, I have created an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"API.js\"), \" inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"utils\"), \" directory which we handle all the requests and fetching data, in simple terms AJAX requests between our client and the server.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import axios from 'axios';\\n\\nexport default {\\n    // Gets all books\\n    getBooks: function() {\\n        return axios.get('/api/books');\\n    },\\n    // Gets the book with the given id\\n    getBook: function(id) {\\n        return axios.get('/api/books/' + id);\\n    },\\n    // Deletes the book with the given id\\n    deleteBook: function(id) {\\n        return axios.delete('/api/books/' + id);\\n    },\\n    // Saves a book to the database\\n    saveBook: function(bookData) {\\n        return axios.post('/api/books', bookData);\\n    }\\n};\\n\")), mdx(\"p\", null, \"We also have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pages\"), \" and a separate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"components\"), \" directory. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pages\"), \" contain those files that are going to display the content when we add a book and its author in our list using a form to submit the data to the backend. The form itself uses different reusable components which are built separately. The sole purpose of doing this is to follow best practices that are convenient to understand the source code and a common practice in the React community.\"), mdx(\"p\", null, \"There are two pages \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Books\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Details\"), \". Let us go through them.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Books.js\\n\\nimport React, { Component } from 'react';\\nimport DeleteBtn from '../../components/DeleteBtn';\\nimport Jumbotron from '../../components/Jumbotron';\\nimport API from '../../utils/API';\\nimport { Link } from 'react-router-dom';\\nimport { Col, Row, Container } from '../../components/Grid';\\nimport { List, ListItem } from '../../components/List';\\nimport { Input, FormBtn } from '../../components/Form';\\n\\nclass Books extends Component {\\n    state = {\\n        books: [],\\n        title: '',\\n        author: ''\\n    };\\n\\n    componentDidMount() {\\n        this.loadBooks();\\n    }\\n\\n    loadBooks = () => {\\n        API.getBooks()\\n            .then(res => this.setState({ books: res.data, title: '', author: '' }))\\n            .catch(err => console.log(err));\\n    };\\n\\n    deleteBook = id => {\\n        API.deleteBook(id)\\n            .then(res => this.loadBooks())\\n            .catch(err => console.log(err));\\n    };\\n\\n    handleInputChange = event => {\\n        const { name, value } = event.target;\\n        this.setState({\\n            [name]: value\\n        });\\n    };\\n\\n    handleFormSubmit = event => {\\n        event.preventDefault();\\n        if (this.state.title && this.state.author) {\\n            API.saveBook({\\n                title: this.state.title,\\n                author: this.state.author\\n            })\\n                .then(res => this.loadBooks())\\n                .catch(err => console.log(err));\\n        }\\n    };\\n\\n    render() {\\n        return (\\n            <Container fluid>\\n                <Row>\\n                    <Col size=\\\"md-6\\\">\\n                        <Jumbotron>\\n                            <h1>What Books Should I Read?</h1>\\n                        </Jumbotron>\\n                        <form>\\n                            <Input\\n                                value={this.state.title}\\n                                onChange={this.handleInputChange}\\n                                name=\\\"title\\\"\\n                                placeholder=\\\"Title (required)\\\"\\n                            />\\n                            <Input\\n                                value={this.state.author}\\n                                onChange={this.handleInputChange}\\n                                name=\\\"author\\\"\\n                                placeholder=\\\"Author (required)\\\"\\n                            />\\n\\n                            <FormBtn\\n                                disabled={!(this.state.author && this.state.title)}\\n                                onClick={this.handleFormSubmit}\\n                            >\\n                                Submit Book\\n                            </FormBtn>\\n                        </form>\\n                    </Col>\\n                    <Col size=\\\"md-6 sm-12\\\">\\n                        <Jumbotron>\\n                            <h1>Books On My List</h1>\\n                        </Jumbotron>\\n                        {this.state.books.length ? (\\n                            <List>\\n                                {this.state.books.map(book => (\\n                                    <ListItem key={book._id}>\\n                                        <Link to={'/books/' + book._id}>\\n                                            <strong>\\n                                                {book.title} by {book.author}\\n                                            </strong>\\n                                        </Link>\\n                                        <DeleteBtn onClick={() => this.deleteBook(book._id)} />\\n                                    </ListItem>\\n                                ))}\\n                            </List>\\n                        ) : (\\n                            <h3>No Results to Display</h3>\\n                        )}\\n                    </Col>\\n                </Row>\\n            </Container>\\n        );\\n    }\\n}\\n\\nexport default Books;\\n\")), mdx(\"p\", null, \"We are defining a local state to manage data and pass it on to the API from the component. Methods like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"loadBooks\"), \" are making AJAX requests through the API calls we defined inside \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"utils/API.js\"), \". Next is the details page.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Details.js\\nimport React, { Component } from 'react';\\nimport { Link } from 'react-router-dom';\\nimport { Col, Row, Container } from '../../components/Grid';\\nimport Jumbotron from '../../components/Jumbotron';\\nimport API from '../../utils/API';\\n\\nclass Detail extends Component {\\n    state = {\\n        book: {}\\n    };\\n\\n    componentDidMount() {\\n        API.getBook(this.props.match.params.id)\\n            .then(res => this.setState({ book: res.data }))\\n            .catch(err => console.log(err));\\n    }\\n\\n    render() {\\n        return (\\n            <Container fluid>\\n                <Row>\\n                    <Col size=\\\"md-12\\\">\\n                        <Jumbotron>\\n                            <h1>\\n                                {this.state.book.title} by {this.state.book.author}\\n                            </h1>\\n                        </Jumbotron>\\n                    </Col>\\n                </Row>\\n\\n                <Row>\\n                    <Col size=\\\"md-2\\\">\\n                        <Link to=\\\"/\\\">\\u2190 Back to Authors</Link>\\n                    </Col>\\n                </Row>\\n            </Container>\\n        );\\n    }\\n}\\n\\nexport default Detail;\\n\")), mdx(\"p\", null, \"It shows the books I have added in my list. To use it, first we are going to connect it with Node.js.\"), mdx(\"h3\", null, \"Connecting React and\\xA0Node\"), mdx(\"p\", null, \"There are two build steps we have to undergo through in making a connection between our client side and server side. First, open the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"package.json\"), \" file inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client\"), \" directory and enter a proxy value that points to the same URL on which server is serving the API.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"\\\"proxy\\\": \\\"http://localhost:5000\\\"\\n\")), mdx(\"p\", null, \"Next step is to run the command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yarn build\"), \" inside the client directory such that it builds up the project. If you haven't run this command before in this project, you will notice a new directory suddenly appears.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/800/1*K5i8irozZCKYpIodE6hgng.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"We also need to make two changes to our backend, to serve this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"build\"), \" directory. The reason we are doing this is to deploy our full stack application later on Heroku as one. Of course, you can two deployment servers where one is serving the REST API such as our backend and the other serves the client end, the build folder we just created.\"), mdx(\"p\", null, \"Open \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"routes/index.js\"), \" and add the following line.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// routes/index.js\\nconst router = require('express').Router();\\nconst bookRoutes = require('./books');\\nconst path = require('path');\\n\\n// API routes\\nrouter.use('/api/books', bookRoutes);\\n\\n// If no API routes are hit, send the React app\\nrouter.use(function(req, res) {\\n    res.sendFile(path.join(__dirname, '../client/build/index.html'));\\n});\\n\\nmodule.exports = router;\\n\")), mdx(\"p\", null, \"Next, open the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"server.js\"), \" to in which we add another line using Express built-in middleware that serves static assets.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// server.js\\nconst express = require('express');\\nconst app = express();\\n\\nconst routes = require('./routes');\\n\\nconst PORT = process.env.PORT || 5000;\\n\\n// require db connection\\nrequire('./models');\\n\\n// configure body parser for AJAX requests\\napp.use(express.urlencoded({ extended: true }));\\napp.use(express.json());\\n\\n// ADD THIS LINE\\napp.use(express.static('client/build'));\\n\\napp.use(routes);\\n\\n// Bootstrap server\\napp.listen(PORT, () => {\\n    console.log(`Server listening on port ${PORT}.`);\\n});\\n\")), mdx(\"p\", null, \"Now you can open your terminal and run the following command.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"npm run start\\n\")), mdx(\"p\", null, \"This will trigger our server at url \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"http://localhost:5000\"), \". Visit it using a browser and see your MERN stack app in action like below. For brevity, I haven't much styled but go ahead and showcase your CSS skills.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/800/1*V3ZbTRYfdUc2jnEWHsPEdQ.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"To verify that the data from our application is being added to the database, go to your mlab MongoDB deployment. You will notice a collection appearing with the name of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"books\"), \". Open it and you can see the data you have just submitted through the form. Here is how mine looks like.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/800/1*mNSQyfBe_qzh_IyUZdaT_w.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"I already have two records.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/800/1*dfYnIQotE5nFr3UhkDIb9g.png\",\n    \"alt\": null\n  })), \"\\n\", mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/800/1*mauB7W6yd80fS5gmWHomPA.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Since everything is running locally without any problem, we can move to the next part.\"), mdx(\"h3\", null, \"Deploying on\\xA0Heroku\"), mdx(\"p\", null, \"This is our final topic in this tutorial. Now, all you need is to have a free Heroku account and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://devcenter.heroku.com/articles/heroku-cli\"\n  }), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"Heroku toolbelt\")), \" to run the whole deployment process from your terminal.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"The Heroku Command Line Interface (CLI) makes it easy to create and manage your Heroku apps directly from the terminal. It\\u2019s an essential part of using Heroku. ~\"), \" \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://devcenter.heroku.com/articles/heroku-cli\"\n  }), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"Official Documentation\")))), mdx(\"p\", null, \"To download the Heroku CLI interface visit \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://devcenter.heroku.com/articles/heroku-cli\"\n  }), \"this link\"), \". Depending on your operating system, you can download the packager. You can also choose a simpler method that is to install the cli interface using npm.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm install -g heroku\")), mdx(\"p\", null, \"After you go through the download and installation process, you can verify that everything has installed correctly.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"heroku --version\\n# Output\\nheroku/7.16.0 darwin-x64 node-v8.12.0\\n\")), mdx(\"p\", null, \"Modify \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"package.json\"), \" by adding the following script.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"\\\"scripts\\\": {\\n        \\\"start\\\": \\\"node server.js\\\",\\n        [...]\\n    }\\n\")), mdx(\"p\", null, \"Login to your Heroku account with credentials by running command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"heroku login\"), \" like below.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/800/1*Tfgopqciv5qCw_YzDXOM6A.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Next, create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Procfile\"), \" in the root folder with following value.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"web: npm run start\\n\")), mdx(\"p\", null, \"Once you are logged in traverse to the project directory of your MERN stack application. Run the following command to create a Heroku instance of your app. Make sure you are in the main directory and not in the client folder.\"), mdx(\"p\", null, \"Before we go on to prepare our project for Heroku, I am going to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git\"), \" to push our current project. This is the most common and safe way to use it with Heroku cli interface. Run the following commands in the order described.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"# initialize our project as git repository\\ngit init\\n\\n# prepare the stage\\ngit add .\\n\\n# Commit all changes to git\\ngit commit -m \\\"commit all changes\\\"\\n\")), mdx(\"p\", null, \"Then run:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"heroku create\\n\")), mdx(\"p\", null, \"When this command runs successfully, it gives you an app id like this. Remember this app id as we are going to use it set our existing mlab MongoDB URI.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/800/1*75t_1Se-SNCHrQ67CIKwmQ.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Next step is to connect the existing mlab deployment from our Heroku app.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"heroku config:set MONGODB_URI=mongodb://user:password@ds125453.mlab.com:25453/mern-example -a damp-dusk-80048\\n\")), mdx(\"p\", null, \"You can also use the free tier of mlab provided by Heroku using the following command in case you haven\\u2019t deployed your database previously. This command must only be run in case you are not already using mlab for your Mongodb deployment.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"heroku addons:create mongolab\\n\")), mdx(\"p\", null, \"You can verify that the configuration value has been set by running:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"heroku config:get MONGODB_URI --app damp-dusk-80048\\n\\n# Output\\n\\nmongodb://user:password@ds125453.mlab.com:25453/mern-example\\n\")), mdx(\"p\", null, \"Note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"user\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"password\"), \" in above commands are your mlab credentials that have been discussed on how to set up them in previous sections of this article. Next step is to push the whole app to Heroku.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"# Push to heroku\\n\\ngit push heroku master\\n\")), mdx(\"p\", null, \"This points to Heroku remote instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"origin\"), \". This above command sends the source code to Heroku and from then Heroku reads \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"package.json\"), \" only to install \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dependencies\"), \". That is the reason we defined \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"start\"), \" script rather using the than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"server\"), \" one because Heroku or a deployment server has no use of development environment dependencies such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nodemon\"), \".\"), mdx(\"p\", null, \"Finishing the building of your project may look similar to mine.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/800/1*jsmi-MziaelOUtB_2Mbn4Q.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"You can then visit the URL given by Heroku like below. Do notice the already existing data that we deployed using local server in the previous section.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/800/1*PQTWi9hFs29cI2B2IsRRDw.png\",\n    \"alt\": null\n  }))), mdx(\"h3\", null, \"Conclusion\"), mdx(\"p\", null, \"There are many deployment techniques that you can try on Heroku. The technique described in this article is just one of them. I hope you have this article has helped you out.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cdn-images-1.medium.com/max/800/1*H7kqyahThCaSx77QSjO_8A.png\",\n    \"alt\": null\n  }))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://medium.com/crowdbotics/deploy-a-mern-stack-app-on-heroku-b0c255744a70\"\n  }), \"Originally published at Crowdbotics\"))));\n}\n;\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"d9d8ebdd-348c-5c9f-8a1b-eb073dd45ded","prev":{"id":"f7ab86d9-056b-5458-a505-bff7b34e10ad","parent":{"name":"index","sourceInstanceName":"blog"},"excerpt":"There are quite a few  Node.js  frameworks available for web development to build a back-end server for a web or a mobile application. The most popular framework is ExpressJS, which has been used widely in the industry for a long time. In this…","fields":{"title":"Building a REST API with KoaJS","slug":"building-a-rest-api-with-koajs","date":"2018-10-16T00:00:00.000Z"},"code":{"scope":""}},"next":{"id":"9849cf08-b02b-5537-b5ad-78a69eddd283","parent":{"name":"index","sourceInstanceName":"blog"},"excerpt":"React Native takes advantage of Geolocation API that is by default accessible in the web. This API returns different methods such as  getCurrentPosition , and  watchPosition  which are available in React Native as polyfill. To demonstrate how to use…","fields":{"title":"Using Geolocation in React Native","slug":"geolocation-react-native","date":"2018-09-30T00:00:00.000Z"},"code":{"scope":""}}}}}