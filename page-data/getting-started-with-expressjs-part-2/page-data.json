{"componentChunkName":"component---src-templates-post-js","path":"/getting-started-with-expressjs-part-2","webpackCompilationHash":"c3a562291cd8e443a353","result":{"data":{"site":{"siteMetadata":{"title":"Aman Mittal - Fullstack Developer","description":"Aman Mittal - Developer and Technical writer.","author":{"name":"Aman Mittal"},"keywords":["Fullstack Developer"]}},"mdx":{"frontmatter":{"title":"Getting Started With Expressjs Part 2","date":"July 01, 2018","author":"Aman Mittal","banner":null,"slug":"getting-started-with-expressjs-part-2","keywords":null},"code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"slug\": \"getting-started-with-expressjs-part-2\",\n  \"date\": \"2018-07-01T00:00:00.000Z\",\n  \"title\": \"Getting Started With Expressjs Part 2\",\n  \"categories\": [\"nodejs\"],\n  \"description\": \"---\",\n  \"published\": true,\n  \"author\": \"Aman Mittal\",\n  \"banner\": null\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In Part 1, Getting Started With Expressjs, we did learn a lot about how Expressjs works as a Node.js framework. We built a simple and generic web server in the previous article that had two routes to function. We then discussed other paradigms such as devDependencies, REST services and the general anatomy of an Express application. In this article, we are going to continue to build upon the previous article and we will start by generating a boilerplate project that can be used in any scenario, whether building an application using Express completely or just building a REST API using it.\"), mdx(\"h2\", null, \"Introducing Express Generator\"), mdx(\"p\", null, \"Building a web server from scratch time after time can be a tedious process. As a human being, it will be time consuming and in 2 out of 10 cases, there will be chances that you might forget about one configuration or the other and the whole server is not working. To overcome these problems, Express comes with a module that can be installed globally on a local machine, called express-generator. It is a generator tool through which as a developer you can create and populate different routes using database calls and views or template (if using a template engine).\"), mdx(\"p\", null, \"We will build rest of the series using this tool so it will be better if you install it. From your terminal, run this command:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"npm install express-generator -g\\n\")), mdx(\"p\", null, \"To create our project, we will continue to build in the same directory. We will also be using a default template engine which will be explained later in this article.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"express --view=pug\\n\")), mdx(\"p\", null, \"If you want to build the app from scratch, the only option you are missing from the above command is the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"name\"), \" of the project:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"express express-server --view=pug\\n\")), mdx(\"p\", null, \"Installing express-generator gives access to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"express\"), \" command which can be used to scaffold a project structure and a basic web server. There are various options you can choose when starting out with a new project. Such as:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"$ express --help\\n\\n  Usage: express [options] [dir]\\n\\n  Options:\\n\\n    -h, --help           output usage information\\n        --version        output the version number\\n    -e, --ejs            add ejs engine support\\n        --pug            add pug engine support\\n        --hbs            add handlebars engine support\\n    -H, --hogan          add hogan.js engine support\\n    -v, --view <engine>  add view <engine> support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)\\n    -c, --css <engine>   add stylesheet <engine> support (less|stylus|compass|sass) (defaults to plain css)\\n        --git            add .gitignore\\n    -f, --force          force on non-empty directory\\n\")), mdx(\"p\", null, \"You can always choose a view/template engine using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--view\"), \" along with a CSS engine using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--css\"), \" since there is huge support for various commonly used css generators such as SASS and LESS.\"), mdx(\"h2\", null, \"Running the Express-Generator Project\"), mdx(\"p\", null, \"Notice the directory structure of the newly created application. It is close MVC (model-view-controller) design pattern. We will be building our controllers part later but for now, we can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"routes/\"), \" for it. The Model part will be our database that is not defined in this structure and we will have to add it manually. The views are available to us in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"views/\"), \" directory.\"), mdx(\"p\", null, \"The package.json defines the application dependencies and other information. Let us take a look at it:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"name\\\": \\\"node-js\\\",\\n  \\\"version\\\": \\\"0.0.0\\\",\\n  \\\"private\\\": true,\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"node ./bin/www\\\"\\n  },\\n  \\\"dependencies\\\": {\\n    \\\"cookie-parser\\\": \\\"~1.4.3\\\",\\n    \\\"debug\\\": \\\"~2.6.9\\\",\\n    \\\"express\\\": \\\"~4.16.0\\\",\\n    \\\"http-errors\\\": \\\"~1.6.2\\\",\\n    \\\"morgan\\\": \\\"~1.9.0\\\",\\n    \\\"pug\\\": \\\"2.0.0-beta11\\\"\\n  }\\n}\\n\")), mdx(\"p\", null, \"By default, there is no devDependencies installed in this project, we will be adding one sooner than later. On comparing to the previous project, we defined bootstrapping configuration in a file called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.js\"), \". This time, using this tool, our the configuration to run the Express server is available to us in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/bin/www\"), \". This file further loads another file called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app.js\"), \" which we will be using to define our own custom configuration and other essential parts such as defining a template engine, defining routes and other middleware functions.\"), mdx(\"p\", null, \"The dependencies that come with this project are bare minimum but enough trigger a basic web server up and running. First of all the most important dependency of all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"express\"), \". Then there is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"debug\"), \" module which you will see it in action below and is a node debugging utility, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pug\"), \" our template engine, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"http-errors\"), \" to catch HTTP methods errors gracefully, and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cookie-parser\"), \" which is used to parse the information such as cookie header and populate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"req.cookies\"), \" between a client and server. Lastly, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"morgan\"), \" which is an HTTP request logger middleware for Node.js.\"), mdx(\"p\", null, \"For now, we are going to install another dependnency called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"body-parser\"), \" which is another essential dependency we need and is used to parse body of an incoming HTTP request. It makes our job as a developer to be easier as it helps in extracting different part of an incoming HTTP request as information useful to our application. Mostly, we need this when we are working with forms or any other POST HTTP requests from our client.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"npm install --save body-parser\\n\")), mdx(\"p\", null, \"To run this project, we will have to install dependencies available to us by default.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"npm install\\n\")), mdx(\"p\", null, \"Then we can run this project by running:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"DEBUG=node-js:* npm start\\n\")), mdx(\"p\", null, \"To verify if our project is running, open the browser window and visit \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://localhost:3000\"\n  }), \"http://localhost:3000\"), \". You know have a basic working web server plus Expressjs application. At this step, we will also enable auto server restart on file changes as this functionality is not handled by Express framework by default. We will be using nodemon for this. To know how to install and use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nodemon\"), \" refer to article one in this series. Also, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DEBUG\"), \" is provided to us by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"debug\"), \" dependency.\"), mdx(\"p\", null, \"To close this section, we will be changing our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"scripts\"), \" object in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"package.json\"), \" file to make use of nodemon.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"\\\"scripts\\\": {\\n    \\\"start\\\": \\\"node ./bin/www\\\",\\n    \\\"devstart\\\": \\\"nodemon ./bin/www\\\"\\n  }\\n\")), mdx(\"p\", null, \"We can start our development server now by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm run devstart\"), \" and nodemon will watch for file changes.\"), mdx(\"h2\", null, \"What is \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"app.js\"), \"?\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app.js\"), \" file is where define our most configuration and other necessary essentials such as routes to build the web server. This file is created by express-generator and name of the file is a convention with the community. Along with setting up the application, this file also defines various middleware functions and lastly exports \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app\"), \" as a module to be used in other parts of the application. On practical example of using this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app\"), \" module is in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/bin/www\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"#!/usr/bin/env node\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar app = require('../app')\\n\")), mdx(\"p\", null, \"This is how our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app.js\"), \" file looks like now:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"var createError = require('http-errors')\\nvar express = require('express')\\nvar path = require('path')\\nvar cookieParser = require('cookie-parser')\\nvar logger = require('morgan')\\n\\nvar indexRouter = require('./routes/index')\\nvar usersRouter = require('./routes/users')\\n\\nvar app = express()\\n\\n// view engine setup\\napp.set('views', path.join(__dirname, 'views'))\\napp.set('view engine', 'pug')\\n\\napp.use(logger('dev'))\\napp.use(express.json())\\napp.use(express.urlencoded({ extended: false }))\\napp.use(cookieParser())\\napp.use(express.static(path.join(__dirname, 'public')))\\n\\napp.use('/', indexRouter)\\napp.use('/users', usersRouter)\\n\\n// catch 404 and forward to error handler\\napp.use(function(req, res, next) {\\n  next(createError(404))\\n})\\n\\n// error handler\\napp.use(function(err, req, res, next) {\\n  // set locals, only providing error in development\\n  res.locals.message = err.message\\n  res.locals.error = req.app.get('env') === 'development' ? err : {}\\n\\n  // render the error page\\n  res.status(err.status || 500)\\n  res.render('error')\\n})\\n\\nmodule.exports = app\\n\")), mdx(\"p\", null, \"We can see that the file starts by importing various dependencies. We use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"require()\"), \" function. After that, we set \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"views\"), \" to specify the folder where our templates will be stored and then we set \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"view engine\"), \" value to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pug\"), \" to determine which template engine we will be using such that Express framework can identify by the file extension of any views file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".pug\"), \".\"), mdx(\"h2\", null, \"Middleware Functions\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app.use()\"), \" is how we can use any middleware function. Middleware functions are those functions that have access to the request object (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"req\"), \"), the response object (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"res\"), \"), and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function in an application\\u2019s request-response cycle. The motive of these functions is to modify incoming requests and outgoing response objects by performing tasks like parsing request bodies, adding response headers, or by making any other change to request-response cycle. Using a middleware function, you can even end the request-response cycle such as done using a custom error handling middleware function.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" function is the most important of a middleware function and this is what separates it from other regular functions. If a middleware function does include \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next()\"), \" that means the request-response cycle is ended there. The name of the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next()\"), \" here is arbitrary and you can name it whatever you like, however, the name is now stuck within the community and is more of a convention just like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app.js\"), \".\"), mdx(\"p\", null, \"In our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app.js\"), \" you can see the use of both a third party middleware and a custom one. For third-party middleware, we are requiring \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"morgan\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"express.json()\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"express.urlencoded\"), \" etc. For a custom middleware function, see the one that is labeled as to catch \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"404\"), \" errors.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"app.use(function(req, res, next) {\\n  next(createError(404))\\n})\\n\")), mdx(\"h3\", null, \"Error Handling Middleware Function\"), mdx(\"p\", null, \"Another custom middleware function you can notice in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app.js\"), \" fule is the Error middleware function. What separates an error handling middleware function and a normal and how an express application differentiates between the two is the number of arguments passed. Notice in the below error handling middleware function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"// error handler\\napp.use(function(err, req, res, next) {\\n  // set locals, only providing error in development\\n  res.locals.message = err.message\\n  res.locals.error = req.app.get('env') === 'development' ? err : {}\\n\\n  // render the error page\\n  res.status(err.status || 500)\\n  res.render('error')\\n})\\n\")), mdx(\"p\", null, \"There are four arguments passed if compared to a normal middleware function as we learned in the previous section. The extra argument, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"err\"), \" is what separates the two lets the express application differentiate between the two. Also, any error middleware must be defined last in the order. The order of every middleware function is important and you can just replace one with another. The application or the web server might not work. So it is important to keep them in order. This is important because of the request-response cycle.\"), mdx(\"h3\", null, \"Serving Static Files\"), mdx(\"p\", null, \"By default, we do not have to install any dependency use Express as a static server. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"express.static()\"), \" will serve any file defined using a path. We use global variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__dirname\"), \" together with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"path\"), \" module to define such paths.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"app.use(express.static(path.join(__dirname, 'public')))\\n\")), mdx(\"p\", null, \"As a convention, this middleware helps us to serve all static files in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/public\"), \" direcotry of project's root.\"), mdx(\"h3\", null, \"Parsing The HTTP Body\"), mdx(\"p\", null, \"Remember, earlier we installed a module from npm called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"body-parser\"), \"? Well, I am going to tell you now that you will have remove it from your project. The reason is that the latest Express version now includes a second built in middleware function called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"express.json\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"express.urlencoded\"), \" that behave exactly in the same manner as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"body-parser\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"app.use(express.json())\\napp.use(express.urlencoded({ extended: true }))\\n\\n// can be written if using `body-parser`\\n\\nvar bodyParser = require('body-parser')\\n\\napp.use(bodyParser.json())\\napp.use(bodyParser.urlencoded({ extended: false }))\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"body-parser\"), \" have both of these functions. The reason I made you installed this package is that, as Node.js developer you are going to come across older Express versioned projects and you should know the difference or in this case the similarity between the two/\\nYou can uninstall this package by using below command:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"npm uninstall --save body-parser\\n\")), mdx(\"h2\", null, \"Template Engine\"), mdx(\"p\", null, \"Express support various template engines such as handlebars, pug, its previous version jade, ejs, twigs, etc. A Template engine is library that allows us to use any template language. A template language is a special set of instructions that instruct this library to process data and display to on the client. Using a template engine is easy with Express. However, Express comes with a default template engine, Jade, which is the first released version of Pug. To demonstrate how to use a Template Engine, we will be using Pug.\"), mdx(\"p\", null, \"Notice the file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.pug\"), \" in the directory \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"views/\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-pug\"\n  }), \"extends layout\\n\\nblock content\\n  h1= title\\n  p Welcome to #{title}\\n\")), mdx(\"p\", null, \"Do you remember at the start when we ran our server we were displayed with a title called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Express\"), \". The corresponding route for this template is rendering that title for us. You can find the corresponding route in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"routes/index.js\"), \" file.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"var express = require('express')\\nvar router = express.Router()\\n\\n/* GET home page. */\\nrouter.get('/', function(req, res, next) {\\n  res.render('index', { title: 'Express' })\\n})\\n\\nmodule.exports = router\\n\")), mdx(\"p\", null, \"We will now add one more route to this file called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/about\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"router.get('/about', function(req, res, next) {\\n  res.render('about', { title: 'About' })\\n})\\n\")), mdx(\"p\", null, \"Notice the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"res.render()\"), \" which takes the first argument as the name of the template file and then we can send some options that will be used in our views. All this happens quickly behind the scenes. We will add the corresponding template for this route \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"views/about.pug\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-pug\"\n  }), \"extends layout\\n\\nblock content\\n  h1= title\\n  p Welcome to #{title}\\n\")), mdx(\"p\", null, \"If you visit \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://localhost:3000/about\"\n  }), \"http://localhost:3000/about\"), \" URL in your browser you will notice those changes.\"), mdx(\"h2\", null, \"Logging\"), mdx(\"p\", null, \"One more thing to notice here is that, the use logger or morgan module we installed as middleware function early in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app.js\"), \". If you visit the terminal window, you will notice the following output:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"GET / 304 331.932 ms - -\\nGET /stylesheets/style.css 304 10.878 ms - -\\nGET /about 304 23.367 ms - -\\nGET /stylesheets/style.css 304 0.888 ms - -\\nGET /stylesheets/style.css 304 0.596 ms - -\\n\")), mdx(\"p\", null, \"The output is descriptive in itself. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GET /\"), \" is the route part followed by an HTTP status like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"304\"), \". Logging is one of the most useful components when building an application. In production mode, it can be a huge asset if used because it will be working as monitoring utility. Managing a logging component in a Node.js application can help the developer discover and omit problems, errors, etc. quickly and save time. With the help of a proper logging system only, you as a developer will be able to debug your Node.js application if encountered any error. The aim of this article is to help you setup and use logging in a Node.js application. First, there are some requirements for logging a typical Node.js application. Let us see what they are.\"), mdx(\"p\", null, \"There are three requirements for a module logging work. You can think of them as a convention but all these requirements will be helpful to you in development. They are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Timestamps: to convey the time of an event that happened in an application.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Format: there are various logging formats used in the industry. To quickly understand, choose a format that maintains a good balance between being brief and descriptive enough\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Logging Levels: Sometimes having different levels to describe different events can be helpful. These levels could be warning, error, success, etc.\")), mdx(\"p\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console\"), \" methods are a huge part of JavaScript community but they should not be used or relied upon to log an Expressjs application. To get the logging right in your Node.js application, the first thing that comes to mind and practice is using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console\"), \" module. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console\"), \" module is provided by Node.js core API. It is the basic kind of logging and is built in. It can be used for small and spontaneous purposes.\"), mdx(\"p\", null, \"The problem with any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console\"), \" method is that once a problem is encountered, the logs cannot be switched off. It will always print. This is a huge disadvantage at the application level of this module. Another thing that lacks from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console\"), \" API is that you as a developer cannot assign levels of logging.\"), mdx(\"p\", null, \"This where a logging module like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"morgan\"), \" comes into the picture. We are using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dev\"), \" format option and passing it as an argument to our module. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dev\"), \" is the logging format we are using. There are various formats available such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tiny\"), \". Most formats will have a predefined structure just like the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dev\"), \" format:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \":method :url :status :response-time ms - :res[content-length]\\n\")), mdx(\"h2\", null, \"Using Environment Variables with Express Generator\"), mdx(\"p\", null, \"Almost every web server needs some custom configuration. You can define them in a separate file using a convention called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"config.js\"), \" but managing these configurations in applications can be tricky and as the project scales, hard to maintain. Node.js provides us a way to manage these configurations by defining separate environment variables in one application source code which makes the app itself easy to manage. To implement this process, you can use thrid party npm modules like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dotenv()\"), \" but with Express generator tool we are going to use a different approach.\"), mdx(\"p\", null, \"Create a directory in the root of our project \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"config\"), \" inside we will define a file called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"config.json\"), \" where we will store our environmental variables.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"server\\\": {\\n    \\\"port\\\": 3001\\n  }\\n}\\n\")), mdx(\"p\", null, \"We will edit our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bin/www\"), \" script to use this config.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"#!/usr/bin/env node\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar app = require('../app')\\nvar debug = require('debug')('node-js:server')\\nvar http = require('http')\\n// add this line\\nconst config = require('../config/config.json')\\n\\n/**\\n * Get port from environment and store in Express.\\n */\\n\\n// change this line\\nvar port = normalizePort(process.env.PORT || config.server.port)\\napp.set('port', port)\\n\")), mdx(\"p\", null, \"Now if you visit \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"http://localhost:3001/\"), \" you will get the desired result.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://javabeginnerstutorial.com/node-js/getting-started-with-expressjs-part-2/\"\n  }), \"Originally published at javabeginnerstutorial.com\"))));\n}\n;\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"22dd9fee-0bc0-5059-91fb-6ffb5ba12e8d","prev":{"id":"df56b4e6-2891-5e63-9129-85868de3803d","parent":{"name":"index","sourceInstanceName":"blog"},"excerpt":"Start of 2018 🚀 When 2018 arrived I decided to pick up a new framework called  React.js  to enhance my skillset and get more work done remotely. A day came when I was in the middle of React development that I got interested in  React Native  which…","fields":{"title":"Starting Over with React Native","slug":"starting-over-with-react-native","date":"2018-07-07T00:00:00.000Z"},"code":{"scope":""}},"next":{"id":"c02046c7-e7be-5cd6-acd0-cdc88ee4effe","parent":{"name":"index","sourceInstanceName":"blog"},"excerpt":"In the previous article, we learned how we can leverage ODM like Mongoose to connect the database to our Express server web application and define schema and model inside our web application to interact with the MongoDB database. In this tutorial, we…","fields":{"title":"Getting Started With Express Part 4","slug":"getting-started-with-express-part-4","date":"2018-06-28T00:00:00.000Z"},"code":{"scope":""}}}}}