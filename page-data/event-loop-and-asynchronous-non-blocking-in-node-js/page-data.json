{"componentChunkName":"component---src-templates-post-js","path":"/event-loop-and-asynchronous-non-blocking-in-node-js","webpackCompilationHash":"c3a562291cd8e443a353","result":{"data":{"site":{"siteMetadata":{"title":"Aman Mittal - Fullstack Developer","description":"Aman Mittal - Developer and Technical writer.","author":{"name":"Aman Mittal"},"keywords":["Fullstack Developer"]}},"mdx":{"frontmatter":{"title":"Event Loop and Asynchronous Non-Blocking in Node.js","date":"June 02, 2018","author":"Aman Mittal","banner":null,"slug":"event-loop-and-asynchronous-non-blocking-in-node-js","keywords":null},"code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"slug\": \"event-loop-and-asynchronous-non-blocking-in-node-js\",\n  \"date\": \"2018-06-02T00:00:00.000Z\",\n  \"title\": \"Event Loop and Asynchronous Non-Blocking in Node.js\",\n  \"categories\": [\"nodejs\"],\n  \"description\": \"---\",\n  \"published\": true,\n  \"author\": \"Aman Mittal\",\n  \"banner\": null\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Introduction to Node.js Event Loop\"), mdx(\"p\", null, \"Node.js is single threaded. It supports concurrency through paradigms of event and callbacks. Since it is single threaded, most APIs provided by Node.js core are asynchronous. They follow a non-blocking Input/Output or I/O. What is a non-blocking Input/Output you ask?\"), mdx(\"p\", null, \"In a traditional Input/Output, when a request comes to a web server, it is assigned to a specific thread. For each concurrent connection, there is a new thread and the thread will continue to run until a response is sent for a particular request. This is a perfect example of Blocking I/O (Input/Output network operation) because when handling a particular request by a thread there will be some idle time when between operations are being performed such as retrieving a file, opening it, reading it, etc.\"), mdx(\"p\", null, \"Each of these thread consumes memory and thus, a thread which runs for a longer period of time and also sits idely for a significant amount of time in between will definitely consume a lot of memory. This is one of the main reason that the core APIs in Node.js are built in non-blocking way and support asynchronous I/O.\"), mdx(\"p\", null, \"Node.js uses V8 that is a runtime engine developed by Google for Chrome browser to run JavaScript. Basically, V8 is responsible to convert code written in JavaScript into machine level code. Different browsers have different runtime engines. It is the reason Node.js is fast and efficient.\"), mdx(\"p\", null, \"Hence, we can say that Node.js is itself a runtime environment. It follows an observer pattern (also known as Reactor Pattern in other programming languages) which allows each incoming I/O request to be associated and handle within a function or a handler. This handler function is called a callback function.\"), mdx(\"p\", null, \"At the time of running a Node.js environment, an Event Loop is initialized which handles the I/O operations by offloading them to an operating system's kernel. Different operating system use different kernels but their basic mechanism of handling an I/O is similar. These kernels are multi threaded and can handle execution of multiple operations in the background. Whenever an I/O operation completes, the Kernel notifies Node.js about it and callback handling that operation will complete its execution.\"), mdx(\"p\", null, \"All of these operations are queued in a poll which is also known as Event Queue. Any of these operations may proceed to more operations and these new operations are then again added to the Event Queue. In summary, Event Loop will always be responsible for the execution of all the asynchronous callbacks registered for every event in the Event Queue. Other than I/O operations that are queued in the Event Queue or poll the other types of callbacks can also execute with the Event Loop. These other types are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Timers\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"process.nextTick()\"))), mdx(\"h2\", null, \"Timer Functions\"), mdx(\"p\", null, \"In JavaScript, a timer function will always have callback associated with it. This callback indicates the execution as early or defer it, in an Event Loop after the specified amount of time is passed. Each timer function accepts this value in milliseconds. When writing a Node.js module, these functions do not need to be imported via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"require()\"), \". All of these functions are available globally to us by Node.js core API similarly to the browser's JavaScript API. The behaviour of execution of these timer functions in Node.js differs that from the browser API. Let us take a look at them.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"setTimeout()\")), mdx(\"p\", null, \"This timer function is used to schedule the callback associated after described period of time in milliseconds. The first argument to this function is always a callback which can also be declared separately. The second argument of the timer function is the amount of milliseconds defined.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"setTimeout(() => {\\n  console.log(`Set Timeout executed`)\\n}, 1000)\\n\")), mdx(\"p\", null, \"In the above example, the callback associated will execute as close to 1000 milliseconds (or 1 second) as possible due to the call of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setTimeout()\"), \". The Event Loop never guarantees that a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setTimeout()\"), \" function will execute exactly after the expected time. However, it does guarantees that it will not execute before the specified amount of time. This is because there might be other executing asynchronous/synchronous functions might pushed before the execution of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setTimeout()\"), \" function.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"setImmediate()\"))), mdx(\"p\", null, \"This timer function behaves differently and only execudes the code associated at the end of an Event Loop cycle. This code will execute after every I/O operations in the current event loop and before any timers scheduled for the next event loop.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"console.log('before immediate')\\n\\nsetImmediate(arg => {\\n  console.log(`executing immediate: ${arg}`)\\n}, 'during immediate')\\n\\nconsole.log('after immediate')\\n\")), mdx(\"p\", null, \"The above snippet of code will output as:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"before immediate\\nafter immediate\\nexecuting immediate: during immediate\\n\")), mdx(\"p\", null, \"The first argument is again is the callback that assoicaites the code to be deferred. Any other optional arguments can be passed to the function when it is executed, like we we have done above in our example. There is no need to define a time limit to defer the execution of this function since it will always run at the end of an Event Loop cycle in any Node.js program.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"setInterval()\"))), mdx(\"p\", null, \"Now suppose, there is a callback that you want to execute in your Node.js module a multiple times. In that case,\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setInterval()\"), \" can be used. It again, takes a callback as the first arguement and runs infinite number of times. The delay between each iteration is defined in milliseconds. Otherwise, this timer function behave is written in a similar manner as of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setTimeout()\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"function runMultipleTimes() {\\n  console.log('Executing after One Second')\\n}\\n\\nsetInterval(runMultipleTimes, 1000)\\n\")), mdx(\"p\", null, \"To stop a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setInterval()\"), \" function from executing infinite number of times, we can use another function that will perform stop its behaviour, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"clearInterval()\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"process.nextTick()\")), mdx(\"p\", null, \"Apart from all timer functions being global, there is another object that global and does need to be required in any Node.js module. It is called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"process\"), \". Discussing everything this object holds is vast discussion and is out of the scope of this article. However, we are interested in a particular method the API contains and it is called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"process.nexTick()\"), \".\"), mdx(\"p\", null, \"This function, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"process.nexTick()\"), \", is used in applications to defer the execution of an asynchronous function until the next cycle of Event Loop. Each cycle of the Event Loop is called tick. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"process.nextTick()\"), \" runs a callback function. Basically, it is used to manually defer a callback function.\"), mdx(\"p\", null, \"It does not take the argument of defining a time limit as other timer functions. Another major difference between this function and other timer functions is that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"process.nextTick()\"), \" is only available in Node.js while other are also available in JavaScript's browser API.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"function callback() {\\n  console.log('Processed in next iteration')\\n}\\n\\nprocess.nextTick(callback)\\n\\nconsole.log('Processed in the first iteration')\\n\")), mdx(\"p\", null, \"If you save the above program in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".js\"), \" file and try running it using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node index.js\"), \", you will notice that the second \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.log\"), \" statement is printed before the first statement associated within the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"callback()\"), \" even their callback is defined and called before the last \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.log\"), \" statement. Console statements in JavaScript and in Node.js are sychronous. The following output:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"Processed in the first iteration\\nProcessed in next iteration\\n\")), mdx(\"h2\", null, \"Event Emitters\"), mdx(\"p\", null, \"In Node.js events are assoiciated with operations in Event Loop. For example, a TCP network server emits a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"connect\"), \" event every time a new client connects, or a stream can emit a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"data\"), \" event every time a new chunk of data is available to read. These objects in Node.js are called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"event emitters\"), \".\"), mdx(\"p\", null, \"These objects that emit events are defined as the instances of the class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"events.EventEmitter\"), \". These objects reveal an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"eventEmitter.on()\"), \" function that allows one or more functions to be attached to named events emitted. When an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"EventEmitter\"), \" object emits the event, the functions attached to that specific event are called synchronously.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const events = require('events')\\nconst eventEmitter = new events.EventEmitter()\\n\\neventEmitter.on('event', (a, b) => {\\n  const c = a + b\\n  console.log('result: ', c)\\n})\\n\\neventEmitter.emit('event', 1, 2)\\n\")), mdx(\"p\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"eventEmitter.emit()\"), \" we can execute a listener function with appropriate arguments. EventEmitter class allows a subscription based model to define callbacks also known as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"pub/sub\"), \" mechanism. Please note that all the listeners attached to a particular event object are all synchronous functions and execute in the order they are registered.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://javabeginnerstutorial.com/node-js/event-loop-and-asynchronous-non-blocking-in-node-js/\"\n  }), \"Originally published at javabeginnerstutorial.com\"))));\n}\n;\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"9fbe9a80-bcf6-5708-bea1-fa318ef36c6f","prev":{"id":"fd385e05-1d31-5420-ba4b-57b9a2fff60a","parent":{"name":"index","sourceInstanceName":"blog"},"excerpt":"In previous two articles, we discussed on how to build a basic web server using Node.js alone. By Node.js alone, I mean using its core API modules such as  url  and  HTTP . In the second article, we glimpsed briefly on how Node.js works behind the…","fields":{"title":"Getting Started With Expressjs","slug":"getting-started-with-expressjs","date":"2018-06-12T00:00:00.000Z"},"code":{"scope":""}},"next":{"id":"18550c69-7ffd-590f-adfa-8ff8b8932505","parent":{"name":"index","sourceInstanceName":"blog"},"excerpt":"Web applications are often written in a server/client model where server is responsible to respond with resources for the client to handle. Node.js is an open source platform that allows you to build fast and scalable server applications using…","fields":{"title":"Introduction to Node.js","slug":"node-js-network-programming","date":"2018-05-24T00:00:00.000Z"},"code":{"scope":""}}}}}