{"componentChunkName":"component---src-templates-post-js","path":"/getting-started-with-express-part-4","webpackCompilationHash":"c3a562291cd8e443a353","result":{"data":{"site":{"siteMetadata":{"title":"Aman Mittal - Fullstack Developer","description":"Aman Mittal - Developer and Technical writer.","author":{"name":"Aman Mittal"},"keywords":["Fullstack Developer"]}},"mdx":{"frontmatter":{"title":"Getting Started With Express Part 4","date":"June 28, 2018","author":"Aman Mittal","banner":null,"slug":"getting-started-with-express-part-4","keywords":null},"code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"slug\": \"getting-started-with-express-part-4\",\n  \"date\": \"2018-06-28T00:00:00.000Z\",\n  \"title\": \"Getting Started With Express Part 4\",\n  \"categories\": [\"nodejs\"],\n  \"description\": \"---\",\n  \"published\": true,\n  \"author\": \"Aman Mittal\",\n  \"banner\": null\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In the previous article, we learned how we can leverage ODM like Mongoose to connect the database to our Express server web application and define schema and model inside our web application to interact with the MongoDB database. In this tutorial, we are going to work on the controller part of our web server. We will be defining some routes using BookSchema. Let us get started.\"), mdx(\"h2\", null, \"Introduction\"), mdx(\"p\", null, \"Routes are the backbone of a web application built using a server. Without it, you won't be really building a web app. When I say routes here, I mean server side routing. There is a huge difference between a server side route and the client side routing. Routing is the concept in which HTTP requests or client requests are handled by some snippets of code. It is used for navigating in a web application by clicking on a link which further, changes the URL to provide access to a different endpoint in the application.\"), mdx(\"p\", null, \"In server side routing, whenever the endpoint changes, some form of data is requested by the application. This is the main purpose of server side routing. The server will query the database to fulfill the request and sends it as a response. In most Expressjs applications we define our routes in a separate file called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"routes.js\"), \" which handles the business logic such as database queries. For example, take a look at the GET request that will handle the by fetching the list of items from the database.\"), mdx(\"p\", null, \"Server side routes cause the web application to refresh the page. This means, whenever a GET request is sent to the server, the response always comes back to the client as a new document. This is a resource consuming task. For every request, if there is a full page refresh, some of the same data will be transferred back and forth such as the header of the application. Refreshing a page takes time and consumes network resources. This is why need client side routing to navigate for different resources avoiding the web pages to refresh again and again.\"), mdx(\"h3\", null, \"HTTP Verbs\"), mdx(\"p\", null, \"Routing refers to how a server side application responds to a client request to a particular endpoint. This endpoint consists of a URI (a path such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/books\"), \") and an HTTP method associated with it such as GET, POST, PUT, DELETE, etc. Routes can either be simple web pages or REST/GraphQL API endpoints. In both cases, the syntax is similar for a route can be defined in an Expressjs app as:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"app.METHOD(PATH, HANDLER)\\n\")), mdx(\"p\", null, \"Routes help us developers to maintain and scale an application by keeping different endpoints and the business logic behind them as separate concerns. In an Expressjs app, all routes defined must be invoked before the function call of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app.listen()\"), \".\"), mdx(\"p\", null, \"HTTP is a standard protocol for a client and a server to communicate over. It provides different verbs or methods such as GET, POST, PUT, DELETE, PATCH to communicate with the client. Each route in an Express application has a handler that is responsible for sending the response from the server whenever the route is invoked as a URL by the client.\"), mdx(\"p\", null, \"For example, a route of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app.get()\"), \" is used to handle GET requests and in return responds with a message:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"// GET method route\\napp.get('/', (req, res) => res.send('Hello World!'))\\n\")), mdx(\"p\", null, \"The example above uses the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".get()\"), \" method to respond to HTTP GET requests with a certain path (in this case \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/\"), \"). Other HTTP verbs provided to us are post(), put(), delete(), options(), trace(), copy(), lock(), mkcol(), move(), purge(), propfind(), proppatch(), unlock(), report(), \\u200B\\u200B\\u200B\\u200B\\u200B\\u200B mkactivity(), checkout(), merge(), m-search(), notify(), subscribe(), unsubscribe(), patch(), search(), and connect().\"), mdx(\"h3\", null, \"Routing Functions\"), mdx(\"p\", null, \"A routing function is a combination of a route path and a callback handler that that is responsible for sending the response from the server. This callback function takes three arguments that will contain an HTTP Request object, an HTTP response, and the next function in the middleware chain.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"app.get('/home', (req, res) => {\\n  res.send('Home Page')\\n})\\n\")), mdx(\"h3\", null, \"Routing Paths\"), mdx(\"p\", null, \"The route paths are defined as endpoints at which requests from a client can be made. Below when we implement the controller of our application, you will see that we will be defining a route path for the existing database model called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/books\"), \". Routing paths can be strings, string patterns, or regular expressions.\"), mdx(\"p\", null, \"Take a look at the example below. We are defining a route path called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/about\"), \" in first and using wild characters in the second which certainly signifies that it is a combination of string patterns and regular expressions and in the third one we only use a wild character to signify that it is a 404 route.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"app.get('/about', (req, res) => {\\n  // ...\\n})\\n\\napp.get(/.*new$/, function(req, res) {\\n  // ...\\n})\\n\")), mdx(\"h3\", null, \"Routing Parameters\"), mdx(\"p\", null, \"They are named part in a URL that signifies a dynamic value associated with the endpoint. These named parts are prefixed with a colon sign (:) followed by the actual name. The name of route parameters must be made up of characters (\", \"[A-Za-z0-9_]\", \"). Take a look at the example below:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"app.get('/books/:bookId', function(req, res) {\\n  res.send(req.params)\\n})\\n\")), mdx(\"p\", null, \"In the above route example, we can access the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bookId\"), \" from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"req.params.bookId\"), \". This will be equal to the actual URL: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"http://localhost:3000/books/43\"), \".\"), mdx(\"h2\", null, \"Routes in our Web Server\"), mdx(\"p\", null, \"In this section, we will be creating routes for our web server application. Instead of creating routes in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app.js\"), \" we will be defining them in the routes directory. Also, we will be using an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"express.Router()\"), \" instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app.HTTPmethod\"), \". It works similarly and has access to every HTTP method provided.\"), mdx(\"p\", null, \"To start, create a new file called books.js inside routes directory. In this file, we are only going to define the endpoints related to our model. These endpoints are URLs through which any client can send request to our Express based web server.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const express = require('express')\\nconst router = express.Router()\\n\\nconst bookController = require('../controllers/booksController.js')\\n\\n// GET ALL BOOKS titles\\nrouter.get('/', bookController.booksList)\\n\\n// GET a BOOK by id\\nrouter.get('/:id', bookController.getBookById)\\n\\nmodule.exports = router\\n\")), mdx(\"p\", null, \"The routes are all set up on the Router instance which is then exported to be invoked inside app.js file later.\"), mdx(\"p\", null, \"The business logic behind each of there endpoint, that is the callback function or the routing function that will process the incoming request will be handled in a separate file called booksController.js under a separate directory called controllers. You will have to create that at the root of our project.\"), mdx(\"p\", null, \"Open booksController.js and start by import the database model for books.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const Book = require('../models/book.model.js')\\n\\nexports.booksList = (req, res) => {\\n  res.send('NOT IMPLEMENTED: Books list')\\n}\\n\\nexports.getBookById = (req, res) => {\\n  res.send('NOT IMPLEMENTED: Get a single book')\\n}\\n\")), mdx(\"p\", null, \"Now we will require our routes file in app.js after all middleware functions.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"var indexRouter = require('./routes/index')\\nvar usersRouter = require('./routes/users')\\nvar booksRouter = require('./routes/books')\\n\\n// ...\\n\\napp.use('/', indexRouter)\\napp.use('/users', usersRouter)\\napp.use('/books', booksRouter)\\n\\n// catch 404 and forward to error handler\\napp.use(function(req, res, next) {\\n  next(createError(404))\\n})\\n\")), mdx(\"p\", null, \"Start the server by running\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"npm run devstart\\n\")), mdx(\"p\", null, \"Now open a REST client like POSTMAN and visit the URL: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"http://localhost:3001/books\"), \". You will see the below message printed because that is what we are currently sending from business logic or controller assoicated with the particular route.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-shell\"\n  }), \"NOT IMPLEMENTED: Books list\\n\")), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://javabeginnerstutorial.com/wp-content/uploads/2018/06/Screen-Shot-2018-06-28-at-1.18.09-PM-768x360.png\",\n    \"alt\": \"ss1\"\n  }))), mdx(\"p\", null, \"Next we will create a POST route that will add data to the database.\"), mdx(\"p\", null, \"Open routes/books.js add a new route \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/add\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"router.post('/add', bookController.addBook)\\n\")), mdx(\"p\", null, \"In booksController.js, add:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"exports.addBook = (req, res) => {\\n  let newBook = new Book(req.body)\\n\\n  newBook\\n    .save()\\n    .then(data => {\\n      console.log(data)\\n      res.send(data)\\n    })\\n    .catch(err => {\\n      console.log(err)\\n      res.status(400).send('unable to save data')\\n    })\\n}\\n\")), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://javabeginnerstutorial.com/wp-content/uploads/2018/06/Screen-Shot-2018-06-28-at-1.25.35-PM-768x441.png\",\n    \"alt\": \"ss2\"\n  }))), mdx(\"p\", null, \"Notice that we are using promise based \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".then()\"), \" and .catch() methods. These methods are provided by Mongoose to us and we are not using any third party library to do so. Now to see if the data is saved in the database, we will fetch by using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/\"), \" route. Open booksController.js and complete business logic for rest of the two routes:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"exports.booksList = (req, res) => {\\n  Book.find()\\n    .then(data => {\\n      res.send(data)\\n    })\\n    .catch(err => {\\n      console.log(err)\\n      res.status(400).send('unable to fetch books')\\n    })\\n}\\n\\nexports.getBookById = (req, res) => {\\n  Book.findById({ _id: req.params.id })\\n    .then(data => {\\n      res.send(data)\\n    })\\n    .catch(err => {\\n      console.log(err)\\n      res.status(400).send('unable to fetch books')\\n    })\\n}\\n\")), mdx(\"p\", null, \"See the screenshots below and if you get the output and no error that means your routes are working great!\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://javabeginnerstutorial.com/wp-content/uploads/2018/06/Screen-Shot-2018-06-28-at-1.40.23-PM-768x426.png\",\n    \"alt\": \"ss3\"\n  }))), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://javabeginnerstutorial.com/wp-content/uploads/2018/06/Screen-Shot-2018-06-28-at-1.40.29-PM-768x416.png\",\n    \"alt\": \"ss4\"\n  }))), mdx(\"p\", null, \"This completes our fourth part in the series. Stay tuned for more. You can find the source code for at this github repo under tag \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"chapter4\"), \".\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://javabeginnerstutorial.com/node-js/getting-started-with-express-part-4/\"\n  }), \"Originally published at javabeginnerstutorial.com\"))));\n}\n;\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"c02046c7-e7be-5cd6-acd0-cdc88ee4effe","prev":{"id":"22dd9fee-0bc0-5059-91fb-6ffb5ba12e8d","parent":{"name":"index","sourceInstanceName":"blog"},"excerpt":"In Part 1, Getting Started With Expressjs, we did learn a lot about how Expressjs works as a Node.js framework. We built a simple and generic web server in the previous article that had two routes to function. We then discussed other paradigms such…","fields":{"title":"Getting Started With Expressjs Part 2","slug":"getting-started-with-expressjs-part-2","date":"2018-07-01T00:00:00.000Z"},"code":{"scope":""}},"next":{"id":"a51ca0d4-5648-559b-84d1-9116421a3848","parent":{"name":"index","sourceInstanceName":"blog"},"excerpt":"Introduction With an Expressjs application, you can make use of all popular databases available to perform several operations such Create, Read, Update and Delete (CRUD operations). This tutorial will provide an overview of a database we are going to…","fields":{"title":"Getting started with Express application Part 3: Connecting with Database","slug":"getting-started-with-express-part-3","date":"2018-06-24T00:00:00.000Z"},"code":{"scope":""}}}}}